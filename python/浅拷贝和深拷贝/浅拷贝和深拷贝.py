理解浅拷贝影响可变对象的关键在于如何处理对象中的 **引用**。在 Python 中，当你进行浅拷贝时，拷贝的是对象的 **引用** 而非对象本身。因此，拷贝后的对象与原始对象中的可变属性共享同一块内存。这会导致修改其中一个对象的属性时，另一个对象也会受到影响。

### 浅拷贝与可变对象

对于可变对象，浅拷贝只会拷贝对象本身，但它不会拷贝对象内部引用的其他对象。具体来说，**浅拷贝创建了一个新的对象，但其中的属性仍然是对原对象的引用**，尤其是对于对象内的可变属性（如列表、字典、集合等）。

#### 示例：浅拷贝对可变对象的影响

```python
import copy

# 创建一个列表，里面包含一个嵌套的列表
original = [1, 2, [3, 4]]

# 对原始对象进行浅拷贝
shallow_copy = copy.copy(original)

# 修改浅拷贝中的嵌套列表
shallow_copy[2][0] = 99

# 打印原始对象和浅拷贝对象
print("Original:", original)  # 输出：[1, 2, [99, 4]]
print("Shallow Copy:", shallow_copy)  # 输出：[1, 2, [99, 4]]
```

### 解释：
1. **浅拷贝时**，`original` 列表被复制成 `shallow_copy`。但是，`original[2]` 和 `shallow_copy[2]` 都是指向同一个嵌套列表 `[3, 4]` 的引用。
   
2. 修改 `shallow_copy[2][0] = 99` 后，`shallow_copy` 和 `original` 中的嵌套列表变成了 `[99, 4]`，因为这两个列表的引用指向的是同一个嵌套列表。

### 为什么浅拷贝会影响可变对象？
- **对于可变对象**，浅拷贝只复制了对象的“外壳”（即对象本身），但没有递归复制它包含的可变对象（比如列表、字典等）。因此，原对象和拷贝对象中的嵌套对象（如果存在）仍然是同一个对象的引用。
- 对于嵌套在可变对象中的其他可变对象（如列表中的列表），它们 **没有被拷贝**，而是共享相同的内存空间。

### 如何避免浅拷贝影响？

如果你想避免浅拷贝对嵌套可变对象的影响，可以使用**深拷贝**。深拷贝会递归地复制所有嵌套的可变对象，因此不会有引用共享的问题。

#### 示例：使用深拷贝避免影响

```python
import copy

# 创建一个列表，里面包含一个嵌套的列表
original = [1, 2, [3, 4]]

# 对原始对象进行深拷贝
deep_copy = copy.deepcopy(original)

# 修改深拷贝中的嵌套列表
deep_copy[2][0] = 99

# 打印原始对象和深拷贝对象
print("Original:", original)  # 输出：[1, 2, [3, 4]]
print("Deep Copy:", deep_copy)  # 输出：[1, 2, [99, 4]]
```

### 解释：
- 在这个例子中，`deepcopy` 会创建一个完全独立的对象，包括所有的嵌套对象。所以修改 `deep_copy[2][0]` 不会影响 `original` 对象，因为它们的嵌套列表是独立的。

### 总结：
- **浅拷贝**：只复制对象本身，对于嵌套的可变对象，它们的引用被共享。修改共享的可变对象时，原对象和拷贝对象都会发生变化。
- **深拷贝**：递归地复制对象和它包含的所有对象，避免了共享引用，修改一个对象时不会影响另一个对象。

补充：
在 Python 中，对象可以分为**可变对象**（mutable）和**不可变对象**（immutable），两者的主要区别在于对象的值是否可以被修改。以下是一些常见的可变对象和不可变对象的分类：

### **不可变对象 (Immutable Objects)**

不可变对象是指在创建后无法修改其值的对象。对于不可变对象，任何对其内容的修改都会创建一个新的对象。

常见的不可变对象包括：

1. **整数** (`int`)
   ```python
   a = 5
   b = a
   a = 10
   print(b)  # 输出：5
   ```

2. **浮点数** (`float`)
   ```python
   a = 3.14
   b = a
   a = 2.71
   print(b)  # 输出：3.14
   ```

3. **字符串** (`str`)
   ```python
   a = "hello"
   b = a
   a = "world"
   print(b)  # 输出："hello"
   ```

4. **元组** (`tuple`)
   ```python
   a = (1, 2, 3)
   b = a
   a = (4, 5, 6)
   print(b)  # 输出：(1, 2, 3)
   ```

5. **布尔值** (`bool`)
   ```python
   a = True
   b = a
   a = False
   print(b)  # 输出：True
   ```

6. **frozenset**
   ```python
   a = frozenset([1, 2, 3])
   b = a
   a = frozenset([4, 5, 6])
   print(b)  # 输出：frozenset({1, 2, 3})
   ```

### **可变对象 (Mutable Objects)**

可变对象是指可以在原地修改其值的对象。对可变对象的修改不会创建新的对象，而是直接修改其内容。

常见的可变对象包括：

1. **列表** (`list`)
   ```python
   a = [1, 2, 3]
   b = a
   a[0] = 99
   print(b)  # 输出：[99, 2, 3]
   ```

2. **字典** (`dict`)
   ```python
   a = {'name': 'Alice', 'age': 30}
   b = a
   a['age'] = 31
   print(b)  # 输出：{'name': 'Alice', 'age': 31}
   ```

3. **集合** (`set`)
   ```python
   a = {1, 2, 3}
   b = a
   a.add(4)
   print(b)  # 输出：{1, 2, 3, 4}
   ```

4. **自定义类的实例**（通常如果类的属性是可变的，那么对象就是可变的）
   ```python
   class Person:
       def __init__(self, name, age):
           self.name = name
           self.age = age

   a = Person("Alice", 30)
   b = a
   a.age = 31
   print(b.age)  # 输出：31
   ```

### **总结**

- **不可变对象**：`int`、`float`、`str`、`tuple`、`frozenset`、`bool`。它们的值一旦创建就无法修改，如果尝试修改它们的值，实际上是创建了一个新的对象。
- **可变对象**：`list`、`dict`、`set`、自定义类的实例。它们的值是可以直接修改的。

这种可变性或不可变性对 Python 中的引用和拷贝行为有重要影响。对于可变对象，浅拷贝只会复制对象的引用，修改一个对象会影响另一个；而对于不可变对象，修改时会创建一个新的对象，原对象保持不变。